{"filter":false,"title":"train_deep_coder_mnist.py","tooltip":"/train_deep_coder_mnist.py","undoManager":{"mark":30,"position":30,"stack":[[{"start":{"row":85,"column":32},"end":{"row":85,"column":42},"action":"remove","lines":["train_data"],"id":2},{"start":{"row":85,"column":32},"end":{"row":85,"column":40},"action":"insert","lines":["val_data"]}],[{"start":{"row":86,"column":32},"end":{"row":86,"column":41},"action":"remove","lines":["test_data"],"id":3},{"start":{"row":86,"column":32},"end":{"row":86,"column":40},"action":"insert","lines":["val_data"]}],[{"start":{"row":217,"column":30},"end":{"row":217,"column":83},"action":"remove","lines":["# data augment 되지 않은, 형태가 [img], [img, lab, img]인 데이터"],"id":4}],[{"start":{"row":211,"column":49},"end":{"row":211,"column":117},"action":"remove","lines":[" # predicted lable만을 예측, 이때는 augmented 되지 않은 train data를 이용하기 위해 분리?"],"id":5}],[{"start":{"row":208,"column":19},"end":{"row":208,"column":35},"action":"remove","lines":[" # 트레인 한 후 실행될 것"],"id":6}],[{"start":{"row":201,"column":27},"end":{"row":201,"column":48},"action":"remove","lines":["# 레알 도는부분. 작업이 진짜 실행됨"],"id":7}],[{"start":{"row":183,"column":48},"end":{"row":183,"column":125},"action":"remove","lines":["# out_1: 위에서 쌓은 레이어로 디코더 실행, 결과는 reconstructed img ????? out_1 변수가 받는 값이 두가지?"],"id":8}],[{"start":{"row":182,"column":12},"end":{"row":182,"column":74},"action":"remove","lines":["# reconstructed x1. feature space에서 샘플링한 z가 아니라 임의의 inp_1으로 생성"],"id":9}],[{"start":{"row":180,"column":27},"end":{"row":180,"column":54},"action":"remove","lines":[" # latent dim 사이즈의 input 텐서"],"id":10}],[{"start":{"row":174,"column":61},"end":{"row":174,"column":151},"action":"remove","lines":["#inp_0: train data, out_0 : reconstruted img, out_1: predicted label. (vae)에서 쌓은 레이어로 모델만듦"],"id":11}],[{"start":{"row":137,"column":20},"end":{"row":137,"column":90},"action":"remove","lines":["########### input param의 평균과 분산에 noise(target_mean, sd 기준)가 섞인 샘플링 값을줌"],"id":12}],[{"start":{"row":134,"column":38},"end":{"row":134,"column":144},"action":"remove","lines":[" latent_dim는 output space의 dim이 될것. activation함수는 none임 out_1(라벨값 y)을 위한 layer쌓는중  classifier?????????????"],"id":13}],[{"start":{"row":125,"column":41},"end":{"row":125,"column":43},"action":"remove","lines":["케라"],"id":14}],[{"start":{"row":125,"column":41},"end":{"row":125,"column":113},"action":"remove","lines":["스의 텐서 선언 ???????? input shape만을 위해 X를 사용하고 데이터 사용 더이상 안함? 텐서는 사이즈만으로 뭘함?"],"id":15}],[{"start":{"row":126,"column":54},"end":{"row":127,"column":0},"action":"remove","lines":["v넷을 여러번 씌워준 결과 emb와 그 shape ???????????????????.",""],"id":16}],[{"start":{"row":116,"column":31},"end":{"row":116,"column":100},"action":"remove","lines":["train data안의 그룹 별로 (img/label이 그룹인듯) 정해진 배치사이즈만큼의 배치 이미지 혹은 배치 라벨을 생성"],"id":17}],[{"start":{"row":120,"column":21},"end":{"row":120,"column":71},"action":"remove","lines":[" train data의 X = img batches , y = [img, lab, img]"],"id":18}],[{"start":{"row":155,"column":61},"end":{"row":155,"column":131},"action":"remove","lines":["위에서만든 layer로 디코더 실행. 근데 사실상 이 디코더에 오기까지 오리지날 트레인 x를 인코드하는거부터 시작됨. vae."],"id":19}],[{"start":{"row":149,"column":18},"end":{"row":150,"column":16},"action":"remove","lines":["# latent space에서 샘플링한 z를 인풋으로하여 아웃풋도 latent space인 fullyconnected layer. 근데 relu함","print(h_decoded)"],"id":20}],[{"start":{"row":148,"column":42},"end":{"row":148,"column":90},"action":"remove","lines":["# n_feat  = conv 넷 결과 shape들의 곱이 ouputspace의 dim"],"id":21}],[{"start":{"row":145,"column":48},"end":{"row":145,"column":119},"action":"remove","lines":[" # out_0_shape = y label값의 형태만큼, predicted label값을 regression으로 만들어낼거임."],"id":22}],[{"start":{"row":144,"column":72},"end":{"row":144,"column":110},"action":"remove","lines":["# 발굴한 feature space에다 노이즈까지 섞어서 샘플링한 z"],"id":23}],[{"start":{"row":216,"column":51},"end":{"row":216,"column":77},"action":"remove","lines":["reconstructed x와 z mean얻어냄"],"id":24}],[{"start":{"row":221,"column":0},"end":{"row":221,"column":1},"action":"remove","lines":["#"],"id":25}],[{"start":{"row":85,"column":32},"end":{"row":85,"column":40},"action":"remove","lines":["val_data"],"id":26},{"start":{"row":85,"column":32},"end":{"row":85,"column":42},"action":"insert","lines":["train_data"]}],[{"start":{"row":86,"column":32},"end":{"row":86,"column":40},"action":"remove","lines":["val_data"],"id":27},{"start":{"row":86,"column":32},"end":{"row":86,"column":41},"action":"insert","lines":["test_data"]}],[{"start":{"row":218,"column":28},"end":{"row":218,"column":29},"action":"insert","lines":["0"],"id":28}],[{"start":{"row":209,"column":49},"end":{"row":209,"column":50},"action":"insert","lines":["]"],"id":29}],[{"start":{"row":209,"column":49},"end":{"row":209,"column":50},"action":"remove","lines":["]"],"id":30}],[{"start":{"row":209,"column":49},"end":{"row":210,"column":0},"action":"insert","lines":["",""],"id":31},{"start":{"row":210,"column":0},"end":{"row":210,"column":16},"action":"insert","lines":["                "]}],[{"start":{"row":210,"column":16},"end":{"row":210,"column":31},"action":"insert","lines":["nb_batches=100,"],"id":32}]]},"ace":{"folds":[],"scrolltop":1093.625,"scrollleft":0,"selection":{"start":{"row":217,"column":51},"end":{"row":217,"column":51},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":131,"state":"start","mode":"ace/mode/python"}},"timestamp":1523134706273,"hash":"2d9ad91568bfb486050417e7f649f81639e764a2"}